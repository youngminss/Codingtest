function solution(A, B) {
  A.sort((a, b) => (b - a < 0 ? -1 : 1));
  B.sort((a, b) => (b - a < 0 ? -1 : 1));

  if(B[0] <= A[A.length - 1]) return 0;

  let result = 0;
  let aIdx = 0;
  let bIdx = 0;

  while(aIdx < A.length) {
    if(A[aIdx] < B[bIdx]) {
      result++;
      bIdx++;
    }
    aIdx++;
  }

  return result;
}

console.log(solution([5, 1, 3, 7], [2, 1, 6, 8]));
console.log(solution([2, 2, 2, 2], [1, 1, 1, 1]));

/**
 * 문제: 숫자 게임 (Level 3)
 * 테마: 정렬, 그리디
 * 출처: https://programmers.co.kr/learn/courses/30/lessons/12987
 * 
 * [Approach]
 * + (조건) A,B 의 길이를 고려했을 때, O(N) 시간내에 가능한 해법이 필요하다.
 * + (목표) B플레이어가 "최대한" 많은 점수를 가지는 것
 *    - 비겨도 0점, 져도 -1 이 아니고 0점
 * + A의 순서가 정해져 있다는 데, 이것을 풀이과정에서 정렬을 해도 되는가 ?
 *   - 된다. A는 순서가 초기에 정해져 있다 생각하기만 하면 될 뿐
 *   - 누가 몇번 째 인지는 상관하지 않는다.
 *   - 문제를 풀 때는, B가 이길 수 있는 최적의 경우만 생각한다.
 * + 가장 많은 승점을 챙길 수 있는 타당성
 *   - A의 현재 숫자를 이길 수 있는 큰 숫자가 현재 B의 숫자라면 승점을 가져온다.
 *   - A의 숫자를 현재 B의 숫자로 이길 수 없다면, B의 다음 숫자를 셋팅하는게 아니라, A를 다음 작은 숫자로 셋팅한다.
 *     - 이것은, B의 큰 숫자를 최대한 지키면서 A를 줄임으로써, B가 전체적으로 이기는 횟수를 증가시키는 핵심
 *     - 같은 의미지만 다른 표현은, B의 상대적으로 더 작은 숫자를 내버림으로써 B의 현재 큰 숫자를 살려두기  
 * 
 * [NOTE]
 * + 처음 접근을 했을 때는, A가 아닌 B를 매 비교시 마다 다음 숫자로 세팅하려했다.
 * + B가 아닌, A를 조작하므로써 B의 현재 최대 숫자를 최대한 살려서 활용한다는 느낌을 살리는 게 포인트다.
 */
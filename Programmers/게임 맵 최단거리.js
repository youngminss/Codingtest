function solution(maps) {
  let n = maps.length;
  let m = maps[0].length;
  let dx = [-1, 0, 1, 0];
  let dy = [0, 1, 0, -1];
  let x, y, nx, ny;

  let deque = [[0, 0]];
  while (deque.length !== 0) {
    [x, y] = deque.shift();

    for (let i = 0; i < 4; i++) {
      [nx, ny] = [x + dx[i], y + dy[i]];
      if (0 <= nx && nx < n && 0 <= ny && ny < m && maps[nx][ny] === 1) {
        maps[nx][ny] = maps[x][y] + 1;
        deque.push([nx, ny]);
      }
    }
  }

  return maps[n - 1][m - 1] === 1 ? -1 : maps[n - 1][m - 1];
}

solution([
  [1, 0, 1, 1, 1],
  [1, 0, 1, 0, 1],
  [1, 0, 1, 1, 1],
  [1, 1, 1, 0, 1],
  [0, 0, 0, 0, 1],
]); // 11

solution([
  [1, 0, 1, 1, 1],
  [1, 0, 1, 0, 1],
  [1, 0, 1, 1, 1],
  [1, 1, 1, 0, 0],
  [0, 0, 0, 0, 1],
]); // -1

solution([
  [1, 1, 1, 1, 1],
  [1, 0, 1, 0, 1],
  [1, 0, 1, 1, 1],
  [1, 1, 1, 1, 1],
  [0, 0, 0, 1, 1],
]); // 9

/**
 * 문제: 게임 맵 최단거리 (Level 2)
 * 테마: BFS
 * 출처: https://programmers.co.kr/learn/courses/30/lessons/1844
 *
 * [Approach]
 * + 시작 위치와 목표 위치는 항상 같다.
 * + BFS를 진행해서 "아직 안 가본 곳(1)"이면 간다.
 *   - 새로 갈 곳 = 기존 위치까지 오는데 거친 절차 + 1 로 업데이트
 * + Deque(갈 수 있는 곳 저장하는 곳)가 비워져서 BFS가 종료
 * + 최종 목적지의 값을 확인한다.
 *   - 1 이 아닌 값 -> 최종 목표 도달까지 최소한의 걸음 수 이므로 반환
 *   - 1 이면 -> 끝내 목적지 까지 못 갔다는 소리이므로 -1 반환
 *
 * [NOTE]
 * + 처음에 정확도는 만점이었으나, 시간초과가 발생
 *   - 이유는, 방문했던 곳을 굳이 가보도록 구현했기 때문
 *   - BFS 절차를 잘 생각해보면, 해당 위치까지 왔다는 건 이전 절차 중에서 가장 최적화된 걸음 수로 전진해왔다는 것을 보장
 *   - 고로 '1'(아직 방문안함) 경우에만 전진하면 된다.
 */
